<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Scrolling Canvas with Zoom Effect</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100vh;
            background-color: #006699;
            overflow: hidden;
        }

        .photobox {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background-color: #f7f7f7;
            z-index: 100000000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; /* 确保内容垂直排列 */
            gap: 5rem; /* 设置圆圈和文字之间的间距 */
            transition: 1s ease-in-out;
        }

        .loading svg {
            width: 5rem;
            margin-bottom: 2rem;
            overflow: visible;
            transition: 0.3s ease;
        }

        .loading svg circle {
            fill: none;
            stroke: #171717;
            stroke-width: 12;
            stroke-dasharray: 160;
            stroke-dashoffset: 160;
            transform-origin: center;
            animation: circle_rotate 3s ease-in infinite;
        }

        @keyframes circle_rotate {
            0% {
                transform: rotate(0deg);
                stroke-dashoffset: 160;
            }

            100% {
                transform: rotate(360deg);
                stroke-dashoffset: -160;
            }
        }

        .loading p {
            font-family: sans-serif;
            font-size: 2rem;
            color: #171717;
            font-weight: 900;
            transition: 0.3s ease;
        }

        .loading_out svg,
        .loading_out p {
            opacity: 0;
        }

        /* 水平方向动画类 */
        .slide-from-right {
            transform: translateX(100%);
        }

        .slide-from-left {
            transform: translateX(-100%);
        }

        .slide-center {
            transform: translateX(0);
        }
    </style>
</head>

<body>
    <div class="loading slide-center">
        <svg viewbox='0 0 50 50'>
            <circle r='25' cx='25' cy='25'></circle>
        </svg>
        <p>&nbsp;&nbsp;&nbsp;Into Infinity</p>
    </div>
    <script>
        document.addEventListener("mousemove", (event) => {
            console.log(`鼠标位置: x=${event.clientX}, y=${event.clientY}`);
        });
    </script>
    <canvas class="photobox" id="canvas1"></canvas>
    <canvas class="photobox" id="canvas2" style="display: none;"></canvas>
</body>
<script>

     // 过渡动画的图片
    let swith_img = {
        img: new Image(),  // 实际的图片对象
        x: 0,              // 图片的 x 坐标
        y: 0,              // 图片的 y 坐标
        img_width: 0,
        img_height: 0,
        scaleFactor: 1,        
        targetScale: 1       
    };

    valid_canvas1 = 1;  // 禁用canvas1上的点击元素 不然会出来同时点击的bug
    // >0 的时候有效
    myRADIUS = 30;
    

    const photobox2 = {
        // canvas对象容器
        canvas: null,
        // canvas 2d上下文
        context: null,
        // 动画相关参数
        animationId: null,
        // 图片相关参数
        
        targetWidth: 0, // 目标宽度
        targetHeight: 0, // 目标高度
        mag_factor: 1.2, // 放大倍数

        // 动画进度
        animationProgress: 0,
        animationSpeed: 0.1, // 动画速度
        
        // 初始化
        init() {
            this.canvas = document.getElementById("canvas2");
            this.context = this.canvas.getContext("2d");
            this.targetHeight = swith_img.img_height / swith_img.scaleFactor * this.mag_factor;
            this.targetWidth = swith_img.img_width / swith_img.scaleFactor * this.mag_factor;
            this.creat_events();
            this.resize();
            this.startAnimation();
        },
        
        // 调整canvas大小
        resize() {
            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;
            console.log(swith_img.x, swith_img.y, swith_img.scaleFactor)
            // this.draw();
        },
        
        creat_events() {
            this.canvas.addEventListener("mousedown", (e) => {
                // 阻止事件继续传播，防止点击穿透
                e.preventDefault();
                e.stopPropagation();
                
                if (canvas2.style.display !== "none") {
                    // 停止正在进行的动画
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                    canvas2.style.display = "none"; 
                    canvas1.style.display = "block";
                 
                }
        });
    },

        // 绘制函数
        draw() {
            // 清空画布
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // 计算左半屏中心位置
            const targetX = this.canvas.width / 3; // 左半部分的中心x坐标
            const targetY = this.canvas.height / 2; // 垂直中心y坐标

            // 计算当前位置（从初始位置逐渐移动到目标位置）
            const currentX = swith_img.x + (targetX - swith_img.x) * this.animationProgress;
            const currentY = swith_img.y + (targetY - swith_img.y) * this.animationProgress;
            
            // 计算当前大小（从初始大小逐渐变为目标大小）
            const currentWidth = swith_img.img_width + (this.targetWidth - swith_img.img_width) * this.animationProgress;
            const currentHeight = swith_img.img_height + (this.targetHeight - swith_img.img_height) * this.animationProgress;
            
            // 计算图片的左上角坐标
            const imgX = currentX - currentWidth / 2;
            const imgY = currentY - currentHeight / 2;
            
            // 设置圆角半径 (可以根据需要调整)
            const radius = myRADIUS; // 圆角半径
            
            // 保存当前上下文状态
            this.context.save();
            
            // 开始创建圆角矩形路径
            this.context.beginPath();
            
            // 绘制圆角矩形路径
            // 从左上角开始，顺时针绘制
            this.context.moveTo(imgX + radius, imgY); // 左上角水平线起点
            this.context.lineTo(imgX + currentWidth - radius, imgY); // 上边水平线
            this.context.arcTo(imgX + currentWidth, imgY, imgX + currentWidth, imgY + radius, radius); // 右上角
            this.context.lineTo(imgX + currentWidth, imgY + currentHeight - radius); // 右边垂直线
            this.context.arcTo(imgX + currentWidth, imgY + currentHeight, imgX + currentWidth - radius, imgY + currentHeight, radius); // 右下角
            this.context.lineTo(imgX + radius, imgY + currentHeight); // 下边水平线
            this.context.arcTo(imgX, imgY + currentHeight, imgX, imgY + currentHeight - radius, radius); // 左下角
            this.context.lineTo(imgX, imgY + radius); // 左边垂直线
            this.context.arcTo(imgX, imgY, imgX + radius, imgY, radius); // 左上角
            
            // 关闭路径
            this.context.closePath();
            
            // 裁剪为圆角矩形区域
            this.context.clip();
            
            // 在裁剪区域内绘制图片
            this.context.drawImage(
                swith_img.img, 
                imgX, 
                imgY, 
                currentWidth, 
                currentHeight
            );
            
            // 恢复上下文状态
            this.context.restore();
        },
        
        // 启动动画
        startAnimation() {
            // 重置动画进度
            this.animationProgress = 0;
            
            const animate = () => {
                // 更新动画进度
                this.animationProgress += this.animationSpeed;
                
                // 如果动画完成，停止动画
                if (this.animationProgress >= 1) {
                    this.animationProgress = 1;
                    this.draw();
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    console.log("Animation completed");
                    return;
                }
                
                // 绘制当前帧
                this.draw();
                
                // 继续下一帧
                this.animationId = requestAnimationFrame(animate);
            };
            
            // 开始动画
            this.animationId = requestAnimationFrame(animate);
        },
        
        // 重新开始动画
        restartAnimation() {
            // 如果有正在进行的动画，先取消
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
            
            // 重新启动动画
            this.startAnimation();
        }
    };
    

    const photobox1 = 
    {
        // canvas对象容器
        canvas: {},
        // canvas 2d上下文
        content: {},
        // 图片的总数
        img_total: 24,
        // 图片排列的总列数
        row_max: 6,
        // 图片排列的总行数
        line_max: 4,
        // 源图片的实际宽高，这里因为图片太大，会占据画布太多位置，故除以一个数让其缩小
        img_width: Math.floor(700 / 2.15),
        img_height: Math.floor(1000 / 2.15),
        // 图片间的上下左右间距
        img_margin: 180,
        // 所有图片纵横排列之后的总宽高，用作图片超出范围的界限判定
        total_width: 0,
        total_height: 0,
        // 图片数据，用以储存每张图片的源以及xy坐标位置
        img_data: 0,
        // 当前画布是否可以移动
        if_movable: false,
        // 动量滚动相关参数
        velocityX: 0,
        velocityY: 0,
        lastX: 0,
        lastY: 0,
        timestamp: 0,
        friction: 0.95, // 摩擦系数，值越小减速越快
        animationId: null, // 用于取消动画的ID
        
        // 缩放效果相关参数
        currentScale: 1,
        targetScale: 1,
        zoomFactor: -0.2, // 比例
        zoomSpeed: 0.05, // 缩放动画速度
        zoomAnimationId: null, // 用于取消缩放动画的ID
        zoomCenter: { x: 0, y: 0 }, // 缩放中心点
        
        // 边缘滚动相关参数
        edgeScrolling: {
            active: false,
            enabled: true,
            threshold: 150, // 距离边缘多少像素开始滚动
            speed: 10, // 滚动速度
            animationId: null, // 用于取消边缘滚动动画的ID
            mouseX: 0, // 当前鼠标X坐标
            mouseY: 0, // 当前鼠标Y坐标
        },
        
        // 当前鼠标悬停的图片id
        hoveredImageIndex: -1,
        hoverAnimationSpeed: 0.1, // 控制图片缩放动画的速度
        targetScaleFactor: 1.25, // 悬浮时的最大缩放比例
        hoverAnimationId: null, // 用于控制悬浮动画的ID
        
        // 初始化
        init() {
    
            this.canvas = document.getElementById("canvas1");
            this.content = document.getElementById("canvas1").getContext("2d");
            // 总宽度等于横向排列的所有图片的宽度和间隔相加，最后一张图片没有右间隔，故需要减去一个间隔，总高度同理
            this.total_width = this.row_max * (this.img_width + this.img_margin) - this.img_margin;
            this.total_height = this.line_max * (this.img_height + this.img_margin) - this.img_margin;
            
            // 添加键盘事件监听，用于启用/禁用边缘滚动功能
            window.addEventListener('keydown', (e) => {
                // 按E键切换边缘滚动功能
                if (e.key === 'e' || e.key === 'E') {
                    this.edgeScrolling.enabled = !this.edgeScrolling.enabled;
                    console.log(`Edge scrolling ${this.edgeScrolling.enabled ? 'enabled' : 'disabled'}`);
                    
                    // 如果禁用了边缘滚动，确保停止相关动画
                    if (!this.edgeScrolling.enabled && this.edgeScrolling.animationId) {
                        cancelAnimationFrame(this.edgeScrolling.animationId);
                        this.edgeScrolling.animationId = null;
                    }
                    // 如果启用了边缘滚动，确保开始相关动画（如果鼠标在画布内）
                    else if (this.edgeScrolling.enabled && !this.edgeScrolling.animationId) {
                        this.edgeScrolling.active = true;
                        this.startEdgeScrolling();
                    }
                }
            });
            
            this.resize();
            this.creat_events();
            this.creat_img_data();
            
            // 默认激活边缘滚动功能
            this.edgeScrolling.active = true;
            this.startEdgeScrolling();
        },
        resize() {
            // 修改canvas宽高以填充满页面
            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;
            // 修改canvas宽高之后，画布内容会被清除，故需要调用一次move_imgs函数，重新生成所有图片
            if (this.img_data) this.move_imgs(0, 0)
        },
        // 创建图片数据即img_data
        creat_img_data() {
            this.img_data = [];
            for (let i = 0; i < this.img_total; i++) {
                let img = new Image();
                img.src = "{{ url_for('static', filename='img/photos/') }}" + `photo (${i + 1}).png`;
      
                // 当图片加载完成之后，创建对应图片数据并添加到img_data中
                img.onload = () => {
                    // 计算该序号图片处于第几行第几列
                    let col_index = i % this.row_max;
                    let line_index = Math.floor(i / this.row_max);
                    // 通过行列序号算出xy坐标
                    let x = col_index * (this.img_width + this.img_margin);
                    let y = line_index * (this.img_height + this.img_margin);
                    if (col_index % 2 !== 0) {
                        y += this.img_height / 2;
                    }
                    // 将其添加到img_data中，并设置初始缩放属性
                    this.img_data.push({ 
                        img, 
                        x, 
                        y, 
                        scaleFactor: 1,   // 当前缩放
                        targetScale: 1    // 目标缩放
                    });
                    // 创建完成之后就绘制一次
                    this.draw();
                };
            };
        },
        onImageHover(img, isHover) {
            // 修改图片的大小（变大或恢复）
            if (isHover) {
                img.currentScale = 1.5; // 放大倍数
            } else {
                img.currentScale = 1; // 恢复原尺寸
            }

            // 重新绘制画布，确保图片大小变化生效
            this.draw();
        },
        // 绑定所有监听事件
        creat_events() {
            window.addEventListener("resize", () => {
                this.resize();
            });
            
            // 当鼠标按下时，记录位置和时间戳，停止正在进行的动画，开始缩放动画
            this.canvas.addEventListener("mousedown", (e) => {
                this.if_movable = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.timestamp = Date.now();
                
                // 记录缩放中心点（鼠标位置）
                this.zoomCenter = { x: e.clientX, y: e.clientY };
                
                // 停止正在进行的动画
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // 重置速度
                this.velocityX = 0;
                this.velocityY = 0;
                
                // 设置目标缩放为放大20%
                this.targetScale = 1 + this.zoomFactor;
                this.startZoomAnimation();
            });
            
            // 当鼠标弹起时，开始惯性滑动，恢复缩放
            this.canvas.addEventListener("mouseup", (e) => {
                console.log("valid ", valid_canvas1);
                this.if_movable = false;
                if(valid_canvas1>0)
                {

                    this.check_img(e.x, e.y);
                    console.log("success");
                }
                    
                else 
                    console.log("failed");
                valid_canvas1 = valid_canvas1 + 1;
                // 设置目标缩放为原始大小
                this.targetScale = 1;
                this.startZoomAnimation();
                
                // 如果速度足够大，启动惯性滚动
                if (Math.abs(this.velocityX) > 0.1 || Math.abs(this.velocityY) > 0.1) {
                    this.startMomentumScroll();
                }
            });
            
            // 当鼠标离开选区时，也启动惯性滚动并恢复缩放
            this.canvas.addEventListener("mouseleave", () => {
                if (this.if_movable) {
                    this.if_movable = false;
                    
                    // 设置目标缩放为原始大小
                    this.targetScale = 1;
                    this.startZoomAnimation();
                    
                    // 如果速度足够大，启动惯性滚动
                    if (Math.abs(this.velocityX) > 0.1 || Math.abs(this.velocityY) > 0.1) {
                        this.startMomentumScroll();
                    }
                }
                
                // 停止边缘滚动
                this.edgeScrolling.active = false;
                if (this.edgeScrolling.animationId) {
                    cancelAnimationFrame(this.edgeScrolling.animationId);
                    this.edgeScrolling.animationId = null;
                }
            });
            
            // 当鼠标进入画布时启动边缘滚动
            this.canvas.addEventListener("mouseenter", () => {
                // 激活边缘滚动
                this.edgeScrolling.active = true;
                this.startEdgeScrolling();
            });
            
            // 当鼠标移动时，更新速度并移动图片
            this.canvas.addEventListener("mousemove", (e) => {
                // 记录鼠标当前位置用于边缘滚动
                this.edgeScrolling.mouseX = e.clientX;
                this.edgeScrolling.mouseY = e.clientY;
                
                this.checkImageHover(e.clientX, e.clientY);

                if (!this.if_movable) return;
                
                // 计算移动距离
                const deltaX = e.clientX - this.lastX;
                const deltaY = e.clientY - this.lastY;
                
                // 更新位置
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                // 计算时间差
                const now = Date.now();
                const elapsed = now - this.timestamp;
                this.timestamp = now;
                
                // 计算速度 (像素/毫秒)
                if (elapsed > 0) {
                    this.velocityX = deltaX / elapsed * 10; // 乘以一个系数使效果更明显
                    this.velocityY = deltaY / elapsed * 10;
                }
                
                // 移动图片
                this.move_imgs(deltaX, deltaY);
            });
        },
        
        // 启动缩放动画
        startZoomAnimation() {
            // 如果已经有缩放动画在运行，先取消它
            if (this.zoomAnimationId) {
                cancelAnimationFrame(this.zoomAnimationId);
            }
            
            const animate = () => {
                // 逐渐接近目标缩放值
                if (Math.abs(this.currentScale - this.targetScale) > 0.001) {
                    this.currentScale += (this.targetScale - this.currentScale) * this.zoomSpeed;
                    this.draw(); // 重新绘制
                    this.zoomAnimationId = requestAnimationFrame(animate);
                } else {
                    // 达到目标缩放，停止动画
                    this.currentScale = this.targetScale;
                    this.draw();
                    cancelAnimationFrame(this.zoomAnimationId);
                    this.zoomAnimationId = null;
                }
            };
            
            // 开始动画
            this.zoomAnimationId = requestAnimationFrame(animate);
        },
        
        // 启动边缘滚动
        startEdgeScrolling() {
            // 如果已经有边缘滚动动画在运行，先取消它
            if (this.edgeScrolling.animationId) {
                cancelAnimationFrame(this.edgeScrolling.animationId);
            }
            
            const animate = () => {
                if (!this.edgeScrolling.active || !this.edgeScrolling.enabled) {
                    cancelAnimationFrame(this.edgeScrolling.animationId);
                    this.edgeScrolling.animationId = null;
                    return;
                }
                
                const { mouseX, mouseY, threshold, speed } = this.edgeScrolling;
                let moveX = 0;
                let moveY = 0;
                
                // 检查鼠标是否靠近左边缘
                if (mouseX < threshold) {
                    moveX = speed * (1 - mouseX / threshold); // 越靠近边缘速度越快
                }
                // 检查鼠标是否靠近右边缘
                else if (mouseX > this.canvas.width - threshold) {
                    moveX = -speed * (1 - (this.canvas.width - mouseX) / threshold);
                }
                
                // 检查鼠标是否靠近上边缘
                if (mouseY < threshold) {
                    moveY = speed * (1 - mouseY / threshold);
                }
                // 检查鼠标是否靠近下边缘
                else if (mouseY > this.canvas.height - threshold) {
                    moveY = -speed * (1 - (this.canvas.height - mouseY) / threshold);
                }
                
                // 如果需要移动，更新图片位置
                if (moveX !== 0 || moveY !== 0) {
                    this.move_imgs(moveX, moveY);
                }
                
                // 继续动画循环
                this.edgeScrolling.animationId = requestAnimationFrame(animate);
            };
            
            // 开始动画
            this.edgeScrolling.animationId = requestAnimationFrame(animate);
        },
        
        // 启动惯性滚动
        startMomentumScroll() {
            const animate = () => {
                // 应用摩擦力减速
                this.velocityX *= this.friction;
                this.velocityY *= this.friction;
                
                // 移动图片
                if (Math.abs(this.velocityX) > 0.1 || Math.abs(this.velocityY) > 0.1) {
                    this.move_imgs(this.velocityX, this.velocityY);
                    this.animationId = requestAnimationFrame(animate);
                } else {
                    // 速度太小，停止动画
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            };
            
            // 开始动画
            this.animationId = requestAnimationFrame(animate);
        },

        checkImageHover(x, y) {
            if (!this.img_data) return;
            
            // 转换屏幕坐标到画布坐标，考虑缩放因素
            const canvasX = (x - this.zoomCenter.x) / this.currentScale + this.zoomCenter.x;
            const canvasY = (y - this.zoomCenter.y) / this.currentScale + this.zoomCenter.y;
            
            // 查找鼠标是否悬浮在某个图片上
            let hoverIndex = -1;
            for (let i = 0; i < this.img_data.length; i++) {
                const img = this.img_data[i];
                if (
                    canvasX >= img.x && 
                    canvasX < img.x + this.img_width &&
                    canvasY >= img.y && 
                    canvasY < img.y + this.img_height
                ) {
                    hoverIndex = i;
                    break;
                }
            }
            
            // 如果悬浮状态改变
            if (hoverIndex !== this.hoveredImageIndex) {
                // 保存旧的悬浮图片索引
                const oldHoverIndex = this.hoveredImageIndex;
                
                // 更新为新的悬浮图片
                this.hoveredImageIndex = hoverIndex;
                
                // 为新悬浮的图片设置目标缩放
                if (this.hoveredImageIndex !== -1) {
                    // 确保图片有scaleFactor属性
                    if (!this.img_data[this.hoveredImageIndex].scaleFactor) {
                        this.img_data[this.hoveredImageIndex].scaleFactor = 1;
                    }
                    // 设置目标缩放
                    this.img_data[this.hoveredImageIndex].targetScale = this.targetScaleFactor;
                    console.log(`Image hovered: Scaling to ${this.targetScaleFactor}x`);
                }
                
                // 为旧悬浮的图片设置目标缩放回1
                if (oldHoverIndex !== -1) {
                    this.img_data[oldHoverIndex].targetScale = 1;
                }
                
                // 启动悬浮动画
                this.startHoverAnimation();
            }
        },
        startHoverAnimation() {
            // 如果已经有悬浮动画在运行，先取消它
            if (this.hoverAnimationId) {
                cancelAnimationFrame(this.hoverAnimationId);
            }
            
            const animate = () => {
                let needsUpdate = false;
                
                // 遍历所有图片，更新那些需要动画的图片
                this.img_data.forEach(img => {
                    // 如果图片有目标缩放且当前缩放不等于目标缩放
                    if (img.targetScale && Math.abs(img.scaleFactor - img.targetScale) > 0.01) {
                        // 平滑过渡到目标缩放
                        img.scaleFactor += (img.targetScale - img.scaleFactor) * this.hoverAnimationSpeed;
                        needsUpdate = true;
                    }
                });
                
                // 如果有任何图片需要更新
                if (needsUpdate) {
                    // 重绘画布
                    this.draw();
                    // 继续动画
                    this.hoverAnimationId = requestAnimationFrame(animate);
                } else {
                    // 所有动画都完成了，停止
                    cancelAnimationFrame(this.hoverAnimationId);
                    this.hoverAnimationId = null;
                }
            };
            
            // 开始动画
            this.hoverAnimationId = requestAnimationFrame(animate);
        },
        // 绘制函数 - 应用缩放并绘制所有图片
        draw() {
            // 清除content
            this.content.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // 保存当前上下文状态
            this.content.save();
            
            // 应用缩放变换
            // 先将原点移到缩放中心
            this.content.translate(this.zoomCenter.x, this.zoomCenter.y);
            // 应用缩放
            this.content.scale(this.currentScale, this.currentScale);
            // 将原点移回去
            this.content.translate(-this.zoomCenter.x, -this.zoomCenter.y);
            
            // 绘制所有图片
            if (this.img_data) {
                this.img_data.forEach((item) => {
                    const { img, x, y } = item;
                    const scale = item.scaleFactor || 1; // 如果没有scaleFactor属性，默认为1
                    const width = this.img_width * scale;
                    const height = this.img_height * scale;

                    // 计算居中位置
                    const offsetX = (width - this.img_width) / 2;
                    const offsetY = (height - this.img_height) / 2;
                    
                    // 计算实际绘制坐标
                    const imgX = x - offsetX;
                    const imgY = y - offsetY;
                    
                    // 设置圆角半径 (可以根据需要调整)
                    const radius = myRADIUS; // 圆角半径，可根据图片大小适当调整
                    
                    // 为每个图片单独创建圆角效果
                    this.content.save(); // 保存当前状态
                    
                    // 开始创建圆角矩形路径
                    this.content.beginPath();
                    
                    // 绘制圆角矩形路径
                    this.content.moveTo(imgX + radius, imgY); // 左上角水平线起点
                    this.content.lineTo(imgX + width - radius, imgY); // 上边水平线
                    this.content.arcTo(imgX + width, imgY, imgX + width, imgY + radius, radius); // 右上角
                    this.content.lineTo(imgX + width, imgY + height - radius); // 右边垂直线
                    this.content.arcTo(imgX + width, imgY + height, imgX + width - radius, imgY + height, radius); // 右下角
                    this.content.lineTo(imgX + radius, imgY + height); // 下边水平线
                    this.content.arcTo(imgX, imgY + height, imgX, imgY + height - radius, radius); // 左下角
                    this.content.lineTo(imgX, imgY + radius); // 左边垂直线
                    this.content.arcTo(imgX, imgY, imgX + radius, imgY, radius); // 左上角
                    
                    // 关闭路径
                    this.content.closePath();
                    
                    // 裁剪为圆角矩形区域
                    this.content.clip();
                    
                    // 在裁剪区域内绘制图片
                    this.content.drawImage(img, imgX, imgY, width, height);
                    
                    // 恢复上下文状态
                    this.content.restore(); // 这会清除裁剪区域，使下一个图片不受影响
                });
            }
            
            // 恢复上下文状态
            this.content.restore();
        },
        
        // 移动所有图片
        move_imgs(x, y) {
            // 遍历所有图片，对每一张图片进行移动，并进行判断
            if (!this.img_data) return;
            
            this.img_data.forEach((img) => {
                img.x += x;
                // 当图片超出总宽度范围时，将图片移动到最右侧，
                // 注意这里减去一个图片宽度是为了让图片提前位移，防止最左侧的图片出现空白行
                if (img.x > (this.total_width - this.img_width))
                    img.x -= this.total_width + this.img_margin;
                // 当图片小于一个负的图片宽度，即向左超出总宽度范围时，将图片移动到最右侧
                if (img.x < -this.img_width)
                    img.x += this.total_width + this.img_margin;
                // 竖向同上
                img.y += y;
                if (img.y > (this.total_height - this.img_height))
                    img.y -= this.total_height + this.img_margin;
                if (img.y < -this.img_height)
                    img.y += this.total_height + this.img_margin;
            });
            
            // 重新绘制画布
            this.draw();
        },
        
        // 获取当前鼠标点击位置下的对应图片数据
        check_img(x, y) {
            // 需要考虑缩放因素，将点击坐标转换为画布坐标
            const canvasX = (x - this.zoomCenter.x) / this.currentScale + this.zoomCenter.x;
            const canvasY = (y - this.zoomCenter.y) / this.currentScale + this.zoomCenter.y;
            
            // 遍历所有图片，找出鼠标xy坐标处于图片内部的那张图片
            let img = this.img_data.find(img =>
                canvasX >= img.x && canvasX < img.x + this.img_width &&
                canvasY >= img.y && canvasY < img.y + this.img_height
            );
            // 如果存在，则输出
            if (img) {
                // const actualX = (img.x - this.zoomCenter.x) * this.currentScale + this.zoomCenter.x;
                // const actualY = (img.y - this.zoomCenter.y) * this.currentScale + this.zoomCenter.y;
                const actualX = img.x - (this.img_width * img.scaleFactor - this.img_width) / 2;
                const actualY = img.y - (this.img_height * img.scaleFactor - this.img_height) / 2;

                const actualW = this.img_width * img.scaleFactor;
                const actualH = this.img_height * img.scaleFactor;
                swith_img = {
                    img: img.img,
                    x: actualX + actualW / 2,                           // Use the transformed coordinates
                    y: actualY + actualH / 2,                           // Use the transformed coordinates
                    img_width: actualW,  // Account for current zoom
                    img_height: actualH,// Account for current zoom
                    scaleFactor: img.scaleFactor || 1,
                    targetScale: img.targetScale || 1
                };
                if (canvas1.style.display !== "none") {
                    valid_canvas1 = -1;
                    canvas2.style.display = "block"; // 显示第二个canvas
                    photobox2.init();
                    canvas1.style.display = "none";  // 隐藏第一个canvas
                }
            }
        }
    };

    
    // 初始化
    photobox1.init();

    
    // 添加窗口大小变化事件
    window.addEventListener("resize", () => {
        if (document.getElementById("canvas1").style.display !== "none") {
            photobox1.resize();
        } else {
            photobox2.resize();
        }
    });
</script>

<script>
    const loading = {
        container: document.querySelector(".loading"),
        in(target, direction) {
            // 从指定方向滑入中央
            if (direction === 'right') {
                this.container.classList.remove('slide-from-left', 'slide-center');
                this.container.classList.add('slide-from-right');
                
                // 短暂延迟后滑入中央
                setTimeout(() => {
                    this.container.classList.remove('slide-from-right');
                    this.container.classList.add('slide-center');
                    
                    // 等待动画完成后跳转，并在URL中添加动画方向信息
                    setTimeout(() => {
                        // 跳转时传递信息：loading应该从哪个方向滑出
                        window.location.href = target + '?slide=left';
                    }, 1000);
                }, 50);
            } else {
                this.container.classList.remove('slide-from-right', 'slide-center');
                this.container.classList.add('slide-from-left');
                
                setTimeout(() => {
                    this.container.classList.remove('slide-from-left');
                    this.container.classList.add('slide-center');
                    
                    setTimeout(() => {
                        window.location.href = target + '?slide=right';
                    }, 1000);
                }, 50);
            }
        },
        out() {
            // 检查URL参数，决定从哪个方向滑出
            const urlParams = new URLSearchParams(window.location.search);
            const slideDirection = urlParams.get('slide');
            
            if (slideDirection === 'left') {
                this.container.classList.remove('slide-center', 'slide-from-right');
                this.container.classList.add('slide-from-left');
            } else if (slideDirection === 'right') {
                this.container.classList.remove('slide-center', 'slide-from-left');
                this.container.classList.add('slide-from-right');
            } else {
                // 默认情况下，初始加载时向左滑出
                this.container.classList.remove('slide-center', 'slide-from-right');
                this.container.classList.add('slide-from-left');
            }
        }
    };
    
    window.addEventListener("load", () => {
        // 短暂延迟后执行滑出动画
        setTimeout(() => {
            loading.out();
        }, 500);
    });
</script>

</html>